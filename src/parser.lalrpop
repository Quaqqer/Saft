use crate::ast;
use crate::span::{Spanned, Span};

grammar;

pub SpannedModule: Spanned<ast::Module> = Spanned<Module>;

Module: ast::Module
    = <items:Spanned<Item>*>
    => ast::Module { items };

Ident: String
    = <s:r"[a-zA-Z_][a-zA-Z0-9_]*">
    => s.to_string();

Item: ast::Item
    = "fn" <ident:Spanned<Ident>> "(" <params:Spanned<Ident>*> ")" "{" <stmts:Spanned<Stmt>*> "}"
    => ast::Item::Fn { ident, params, stmts };

Stmt: ast::Stmt = {
    <expr:Spanned<Expr>> ";"
        => ast::Stmt::Expr(expr),

    "let" <ident:Spanned<Ident>> "=" <expr:Spanned<Expr>> ";"
        => ast::Stmt::Let { ident, expr },
}

TrailBlock: ast::TrailBlock
    = "{" <stmts:Spanned<Stmt>*> <trail_expr:Spanned<Expr>?> "}"
    => ast::TrailBlock(
           stmts,
           trail_expr.map(Box::new),
       );

pub SpannedStmt = Spanned<Stmt>;

pub SpannedTrailBlock = Spanned<TrailBlock>;

pub SpannedExpr = Spanned<Expr>;

StmtOrExpr: ast::StmtOrExpr = {
    <expr:Expr> => ast::StmtOrExpr::Expr(expr),
    <stmt:Stmt> => ast::StmtOrExpr::Stmt(stmt),
}

pub SpannedStmtOrExpr = Spanned<StmtOrExpr>;

Expr: ast::Expr = {
    #[precedence(level="0")]
    Term,

    #[precedence(level="1")] #[assoc(side="left")]

    <l:Spanned<Expr>> "*" <r:Spanned<Expr>>
        => ast::Expr::Mul(Box::new(l), Box::new(r)),

    <l:Spanned<Expr>> "/" <r:Spanned<Expr>>
        => ast::Expr::Div(Box::new(l), Box::new(r)),

    #[precedence(level="2")] #[assoc(side="left")]

    <l:Spanned<Expr>> "+" <r:Spanned<Expr>>
        => ast::Expr::Add(Box::new(l), Box::new(r)),

    <l:Spanned<Expr>> "-" <r:Spanned<Expr>>
        => ast::Expr::Sub(Box::new(l), Box::new(r)),

    #[precedence(level="3")] #[assoc(side="left")]

    <expr:Spanned<Expr>> "(" <args:OptionalSepBy<Spanned<Expr>, ",">> ")"
        => ast::Expr::Call { expr: Box::new(expr), args },

    <expr:Spanned<Expr>> "." <field:Spanned<Ident>>
        => ast::Expr::Access { expr: Box::new(expr), field },
}

Term: ast::Expr = {
    "true" => ast::Expr::Bool(true),
    "false" => ast::Expr::Bool(false),

    <block:TrailBlock> => ast::Expr::Block(block),

    <var:Spanned<Ident>>
        => ast::Expr::Var(var),

    <int_s:r"[0-9]+">
        => ast::Expr::Int(int_s.parse().unwrap()),

    <float_s:r"[0-9]+\.[0-9]*|[0-9]*\.[0-9]+">
        => ast::Expr::Float(float_s.parse().unwrap()),
}

Spanned<T>: Spanned<T>
    = <l:@L> <v:T> <r:@R>
    => Spanned::new(v, Span::new(l, r));

OptionalSepBy<T, Sep>: Vec<T>
    = <v:SepBy<T, Sep>?>
    => v.unwrap_or(vec![]);

SepBy<T, Sep>: Vec<T>
    = <init:First<T, Sep>*> <end:T>
    => {
        let mut l = init;
        l.push(end);
        l
    };

First<T, U>: T = <v:T> U => v;
